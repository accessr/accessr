<script>
  document.getElementById('year').textContent = new Date().getFullYear();

  // XML helpers
  const parser = new window.XMLParser({ ignoreAttributes:false, attributeNamePrefix:'', removeNSPrefix:true });
  const builder = new window.XMLBuilder({ ignoreAttributes:false, attributeNamePrefix:'', format:true });

  const ensureArray = function(x){ return Array.isArray(x) ? x : (x == null ? [] : [x]); };
  const getRuns = function(p){ return ensureArray(p.r); };
  const pStyleName = function(p){ return (p && p.pPr && p.pPr.pStyle && (p.pPr.pStyle.val || p.pPr.pStyle)) || undefined; };
  const setPStyle = function(p, name){ p.pPr = p.pPr || {}; p.pPr.pStyle = { val:name }; };
  const halfPoints = function(pt){ return Math.round(pt*2); };
  const isFakeHeading = function(txt){
    var t = (txt||'').trim(); if(t.length<4) return false;
    return (
      /^[A-Z0-9][A-Z0-9\s\-:&]{3,}$/.test(t) ||
      /^\d+(?:\.\d+)*\s+.+$/.test(t) ||
      /^(Appendix|Annex|Section)\s+\w+/i.test(t)
    );
  };
  const getTextFromParagraph = function(p){
    var s=''; var runs=getRuns(p);
    for(var i=0;i<runs.length;i++){
      var r=runs[i]; var t=r && r.t;
      if (typeof t==='string') s+=t;
      else if (t && typeof t==='object' && t['#text']) s+=t['#text'];
    }
    return s.trim();
  };
  const enforceRunSize = function(r, minPt){
    r.rPr = r.rPr || {};
    var sz = (r.rPr.sz && r.rPr.sz.val!=null) ? r.rPr.sz.val : r.rPr.sz;
    if (sz!=null){
      var n=Number(sz);
      if(!Number.isNaN(n) && n<halfPoints(minPt)){
        r.rPr.sz = { val: halfPoints(minPt) };
        return true;
      }
    }
    return false;
  };
  const ensureRunLang = function(r, lang){
    r.rPr = r.rPr || {};
    var lg = r.rPr.lang;
    var hasLang = lg && (lg.val || lg.eastAsia || lg.bidi);
    if (!hasLang){ r.rPr.lang = { val:lang, eastAsia:lang, bidi:lang }; return true; }
    return false;
  };
  const stripFakeBullet = function(p){
    var runs=getRuns(p); if(!runs.length) return false;
    var r0=runs[0]; var t=r0.t; var s='';
    if(typeof t==='string') s=t; else if(t && typeof t==='object' && t['#text']) s=t['#text'];
    var stripped = s.replace(/^(-|\*|â€¢)\s+/, '');
    if(stripped!==s){
      if(typeof t==='string') r0.t=stripped; else r0.t={'#text':stripped};
      return true;
    }
    return false;
  };
  const isProbableHeaderRow = function(row){
    var cells=ensureArray(row.tc); var hits=0;
    for(var i=0;i<cells.length;i++){
      var c=cells[i];
      var paras=ensureArray(c.p);
      var txt=''; for(var j=0;j<paras.length;j++){ txt += (getTextFromParagraph(paras[j]) + ' '); }
      txt = txt.trim();
      if(!txt) continue;
      if(txt.length<=25) hits++;
      if(/^[A-Z\s0-9]+$/.test(txt)) hits++;
      if(/^[A-Z][a-z]+(\s[A-Z][a-z]+)*$/.test(txt)) hits++;
    }
    return hits >= Math.max(1, Math.floor(cells.length/2));
  };
  const setTableHeaderRow = function(tbl){
    var rows=ensureArray(tbl.tr); if(!rows.length) return false;
    var first=rows[0]; first.trPr = first.trPr || {}; first.trPr.tblHeader = { val:true }; return true;
  };

  function makeReport(file){
    return {
      file: file,
      issues: [],
      add: function(code, message, location, fix, details){
        this.issues.push({ code:code, message:message, location:location, fix_applied:!!fix, details: details||{} });
      },
      toMarkdown: function(){
        if(!this.issues.length) return '# Accessibility Report for `' + this.file + '`\n\nðŸŽ‰ No issues found.\n';
        var out = ['# Accessibility Report for `' + this.file + '`',''];
        for (var i=0;i<this.issues.length;i++){
          var it=this.issues[i];
          var line='- **['+it.code+']** '+it.message+' â€” *'+it.location+'* ('+(it.fix_applied?'âœ… fixed':'âš  needs review')+')';
          if (it.details && Object.keys(it.details).length){
            line+='\n  - details: `'+JSON.stringify(it.details)+'`';
          }
          out.push(line);
        }
        return out.join('\n');
      },
      counts: function(){
        var t=this.issues.length, f=0; for(var i=0;i<t;i++){ if(this.issues[i].fix_applied) f++; }
        return { total:t, fixed:f, flagged:t-f };
      }
    };
  }

  async function readXml(zip, name){
    const xml = await zip.files[name].async('string');
    return parser.parse(xml);
  }
  function writeXml(zip, name, obj){ zip.file(name, builder.build(obj)); }
  function listWordXmlParts(zip){
    const out=[]; const names=Object.keys(zip.files);
    for (let i=0;i<names.length;i++){
      const n=names[i];
      if(/^word\/document\.xml$/.test(n)) out.push(n);
      if(/^word\/header\d+\.xml$/.test(n)) out.push(n);
      if(/^word\/footer\d+\.xml$/.test(n)) out.push(n);
    }
    return out;
  }

  function processDocPart(docObj, report, opts){
    const minFontPt = opts.minFontPt, lang = opts.lang, applyFixes = opts.applyFixes;
    const document = docObj.document; if(!document || !document.body) return;

    const body=document.body, blocks=[];
    const keys=Object.keys(body);
    for (let ki=0; ki<keys.length; ki++){
      const k=keys[ki];
      const arr=ensureArray(body[k]);
      for (let ai=0; ai<arr.length; ai++) blocks.push({type:k,node:arr[ai]});
    }

    // Headings
    let lastH=0;
    for (let i=0;i<blocks.length;i++){
      const blk=blocks[i];
      if(blk.type!=='p') continue;
      const p=blk.node, style=pStyleName(p)||'', txt=getTextFromParagraph(p);
      if(/^Heading\s*([1-9])$/i.test(style)){
        const lvl = Number(style.replace(/[^\d]/g,'')) || 1;
        if(lastH && (lvl-lastH)>1) report.add('H-LEVEL-SKIP','Skipped heading level from H'+lastH+' to H'+lvl,'Paragraph '+(i+1));
        lastH=lvl;
      } else if(isFakeHeading(txt)){
        report.add('H-FAKE','Looks like a heading but is not using a Heading style.','Paragraph '+(i+1),false,{text:txt});
        if(applyFixes){ setPStyle(p,'Heading 2'); report.add('H-FAKE->FIX','Converted fake heading to "Heading 2".','Paragraph '+(i+1),true,{text:txt}); }
      }
    }

    const paragraphs = []; for (let bi=0;bi<blocks.length;bi++){ if(blocks[bi].type==='p') paragraphs.push(blocks[bi].node); }
    let totalImg=0, missingAlt=0, altFixed=0;

    for (let i=0;i<paragraphs.length;i++){
      const p = paragraphs[i];
      let tooSmall=false, sizeFixed=false, langFixed=false;

      const runs=getRuns(p);
      for (let ri=0;ri<runs.length;ri++){
        const r=runs[ri];
        const rPr=r.rPr||{}, sz=(rPr.sz && rPr.sz.val!=null)?rPr.sz.val:rPr.sz;
        if(sz!=null){
          const n=Number(sz);
          if(!Number.isNaN(n) && n<halfPoints(minFontPt)){
            tooSmall=true;
            if(applyFixes){ if(enforceRunSize(r, minFontPt)) sizeFixed=true; }
          }
        }
        if(applyFixes){ if(ensureRunLang(r, lang)) langFixed=true; }

        const drawing=r.drawing;
        if(drawing){
          const inl = drawing.inline; const anc = drawing.anchor;
          const list = [];
          if (Array.isArray(inl)) for(let a=0;a<inl.length;a++) if(inl[a]) list.push(inl[a]); else {}
          if (!Array.isArray(inl) && inl) list.push(inl);
          if (Array.isArray(anc)) for(let a=0;a<anc.length;a++) if(anc[a]) list.push(anc[a]); else {}
          if (!Array.isArray(anc) && anc) list.push(anc);

          for (let di=0; di<list.length; di++){
            const d = list[di];
            if(!d || !d.docPr) continue;
            totalImg++;
            const has = d.docPr.descr && (''+d.docPr.descr).trim()!=='';
            if(!has){ missingAlt++; if(applyFixes){ d.docPr.descr='IMAGE â€“ add descriptive alt text'; altFixed++; } }
          }
        }
      }

      if(tooSmall) report.add('TXT-SIZE','Text under '+minFontPt+'pt detected.','Paragraph '+(i+1));
      if(sizeFixed) report.add('TXT-SIZE->FIX','Raised font size to '+minFontPt+'pt.','Paragraph '+(i+1),true);
      if(langFixed) report.add('DOC-LANG->FIX','Set language to '+lang+' on missing runs.','Paragraph '+(i+1),true);

      const t=getTextFromParagraph(p);
      if(/https?:\/\/\S+/.test(t)) report.add('LINK-RAW','Raw URL found; consider descriptive link text.','Paragraph '+(i+1),false,{text:t});

      if(/^(-|\*|â€¢)\s+\S+/.test(t)){
        const hasNumPr = !!(p && p.pPr && p.pPr.numPr);
        const styleName = (pStyleName(p)||'').toLowerCase();
        const isList = styleName.indexOf('list')>-1;
        if(!hasNumPr && !isList){
          report.add('LIST-FAKE','Paragraph looks like a fake bullet; convert to a real list style.','Paragraph '+(i+1),false,{text:t});
          if(applyFixes){ stripFakeBullet(p); setPStyle(p,'ListParagraph'); report.add('LIST-FAKE->FIX','Converted fake bullet to a list paragraph style.','Paragraph '+(i+1),true); }
        }
      }
    }

    if(totalImg>0 && missingAlt>0){
      report.add('IMG-ALT', missingAlt+' of '+totalImg+' images missing alt text.','Document');
      if(applyFixes && altFixed>0) report.add('IMG-ALT->FIX','Added placeholder alt text to '+altFixed+' image(s).','Document',true);
    }

    const tables = []; for(let bi=0;bi<blocks.length;bi++){ if(blocks[bi].type==='tbl') tables.push(blocks[bi].node); }
    for (let j=0;j<tables.length;j++){
      const tbl = tables[j];
      const rows=ensureArray(tbl.tr); if(!rows.length) continue;
      const first=rows[0]; const already = !!(first && first.trPr && first.trPr.tblHeader);
      if(!already && isProbableHeaderRow(first)){
        report.add('TBL-HEADER','Table likely needs first row marked as header.','Table '+(j+1));
        if(applyFixes){ if(setTableHeaderRow(tbl)) report.add('TBL-HEADER->FIX','Marked first row as a repeating header.','Table '+(j+1),true); }
      }
    }

    // Doc-level language warning (post-fix)
    let hadLang=false;
    outer: for (let pi=0;pi<paragraphs.length;pi++){
      const rr=getRuns(paragraphs[pi]);
      for(let ri=0;ri<rr.length;ri++){
        const lg = rr[ri] && rr[ri].rPr && rr[ri].rPr.lang;
        if(lg && (lg.val||lg.eastAsia||lg.bidi)){ hadLang=true; break outer; }
      }
    }
    if(!hadLang) report.add('DOC-LANG','No document language detected; set a default (e.g., en-AU).','Document');
  }

  async function processFile(file, opts){
    const buffer = await file.arrayBuffer();
    const zip = await JSZip.loadAsync(buffer);
    const parts = listWordXmlParts(zip);
    if(!parts.length) throw new Error('No Word XML parts found in document.');
    const report = makeReport(file.name);

    for (let i=0;i<parts.length;i++){
      const name=parts[i];
      const js = await readXml(zip, name);
      processDocPart(js, report, opts);
      if(opts.applyFixes) writeXml(zip, name, js);
    }

    let fixedBlob = null;
    if(opts.applyFixes){
      const content = await zip.generateAsync({ type:'blob' });
      fixedBlob = new Blob([content], { type:'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
    }
    const md = report.toMarkdown();
    const reportBlob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
    return { report:report, fixedBlob:fixedBlob, reportBlob:reportBlob };
  }

  // UI
  const drop = document.getElementById('drop');
  const fileInput = document.getElementById('file');
  const runBtn = document.getElementById('runBtn');
  const dlFixed = document.getElementById('dlFixed');
  const dlReport = document.getElementById('dlReport');
  const rawReport = document.getElementById('rawReport');
  const status = document.getElementById('status');
  const filename = document.getElementById('filename');
  const summary = document.getElementById('summary');
  const langSel = document.getElementById('lang');
  const minFont = document.getElementById('minFont');
  const autoFix = document.getElementById('autoFix');

  let currentFile = null;

  function setFile(f){
    currentFile = f;
    runBtn.disabled = !currentFile;
    runBtn.setAttribute('aria-disabled', String(!currentFile));
    filename.textContent = currentFile ? ('Selected file: ' + currentFile.name) : '';
    status.textContent = currentFile ? 'Ready to process.' : '';
    dlFixed.style.display = 'none'; dlReport.style.display = 'none';
    rawReport.textContent = ''; summary.textContent = '';
  }

  fileInput.addEventListener('change', function(){ setFile((fileInput.files && fileInput.files[0]) || null); });

  // Drag & drop accessibility
  ['dragenter','dragover'].forEach(function(evt){
    drop.addEventListener(evt, function(e){ e.preventDefault(); e.stopPropagation(); drop.classList.add('hover'); });
  });
  ['dragleave','drop'].forEach(function(evt){
    drop.addEventListener(evt, function(e){ e.preventDefault(); e.stopPropagation(); drop.classList.remove('hover'); });
  });
  drop.addEventListener('drop', function(e){
    var f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
    if (f && /\.docx$/i.test(f.name)) setFile(f);
    else status.innerHTML = "<span class='err'>Please drop a .docx file.</span>";
  });
  drop.addEventListener('click', function(){ fileInput.click(); });
  drop.addEventListener('keydown', function(e){ if (e.key==='Enter' || e.key===' ') { e.preventDefault(); fileInput.click(); } });

  runBtn.addEventListener('click', async function(){
    if (!currentFile) return;
    runBtn.disabled = true; runBtn.setAttribute('aria-disabled','true');
    status.textContent = 'Processingâ€¦ (all on your device)';
    dlFixed.style.display = 'none'; dlReport.style.display = 'none';
    rawReport.textContent = ''; summary.textContent = '';

    try {
      const opts = {
        minFontPt: Number(minFont.value || 11),
        lang: langSel.value || 'en-AU',
        applyFixes: !!autoFix.checked
      };
      const result = await processFile(currentFile, opts);
      const report = result.report, fixedBlob = result.fixedBlob, reportBlob = result.reportBlob;

      const counts = report.counts();
      summary.innerHTML =
        '<span class="pill"><span class="warn">âš </span> Total: ' + counts.total + '</span> ' +
        '<span class="pill"><span class="ok">âœ…</span> Fixed: ' + counts.fixed + '</span> ' +
        '<span class="pill"><span class="warn">â€¢</span> Needs review: ' + counts.flagged + '</span>';

      rawReport.textContent = report.toMarkdown();

      var ts = new Date().toISOString().slice(0,19).replace(/[:T]/g,'-');
      var base = currentFile.name.replace(/\.docx$/i,'') || 'document';

      if (reportBlob) {
        var url1 = URL.createObjectURL(reportBlob);
        dlReport.href = url1;
        dlReport.download = base + '.a11y-report-' + ts + '.md';
        dlReport.style.display = 'inline-flex';
      }
      if (fixedBlob && opts.applyFixes) {
        var url2 = URL.createObjectURL(fixedBlob);
        dlFixed.href = url2;
        dlFixed.download = base + '.fixed-' + ts + '.docx';
        dlFixed.style.display = 'inline-flex';
      }

      status.textContent = opts.applyFixes
        ? 'Done. Download your fixed document and report below.'
        : 'Done. Download your report below.';
    } catch (err) {
      console.error(err);
      status.innerHTML = "<span class='err'>Error:</span> " + (err && err.message ? err.message : String(err));
    } finally {
      runBtn.disabled = !currentFile;
      runBtn.setAttribute('aria-disabled', String(!currentFile));
    }
  });
</script>
